
CHANGELOG / ORDERED TASKS


add nice to thread struct
enumerate nice values

add recent_cpu to thread struct

add static fixedreal_t load_avg
init 0 in thread_init()

implemented fixed point math

add static int ready_threads
init 1 in thread_init()
implement correct updating of ready_threads

implemented thread_get_load_avg()
implemented thread_recalc_load_avg())

removed static tracking of ready threads
add thread_get_ready_threads ()
  backup interrupt state
  disable interrupts
  get size of ready list
  if current thread != idle add 1
  restore 

disabling interrupts moved to timer_interrupt handler
implemented timer_interrupt to recalc load_avg and priority at specified intervals

thread_init() has:
  initial_thread->recent_cpu = 0;
init_thread() has:
  t->recent_cpu = parent->recent_cpu;

add nice to thread struct
thread_init() has:
  initial_thread->nice = NICE_DEFAULT;
init_thread() has:
  t->nice = parent->nice;

implemented set and get nice functions

added thread_recalc_recent_cpu()



----------------


get/set nice
  "The initial thread starts with a nice value of zero. Other threads start with a nice value inherited from their parent thread."
  
  
  
get/recalc recent_cpu
  The initial value of recent_cpu is 0 in the first thread created, or the parent's value in other new threads. 
  Each time a timer interrupt occurs, recent_cpu is incremented by 1 for the running thread only, unless the idle thread is running. 
  In addition, once per second the value of recent_cpu is recalculated for every thread (whether running, ready, or blocked), using this formula:

  recent_cpu = (2*load_avg)/(2*load_avg + 1) * recent_cpu + nice
  
  
  
get/recalc load_avg
  At system boot, it is initialized to 0. Once per second thereafter, it is updated according to the following formula:

load_avg = (59/60)*load_avg + (1/60)*ready_threads,

  where ready_threads is the number of threads that are either running or ready to run at time of update (not including the idle thread).
  Because of assumptions made by some of the tests, load_avg must be updated exactly when the system tick counter reaches a multiple of a second, that is, when timer_ticks () % TIMER_FREQ == 0, and not at any other time.
